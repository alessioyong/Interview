## Java基础

### Java字符串常量池

~~~java

public class StringPoll58Demo {

    public static void main(String[] args) {
        String str1 = new StringBuilder("58").append("tongcheng").toString();
        System.out.println(str1);
        System.out.println(str1.intern());
        System.out.println(str1==str1.intern());

        System.out.println();

        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str2);
        System.out.println(str2.intern());
        System.out.println(str2==str2.intern());
    }
}
~~~



~~~java
    /**
     * Returns a canonical representation for the string object.
     * <p>
     * A pool of strings, initially empty, is maintained privately by the
     * class {@code String}.
     * <p>
     * When the intern method is invoked, if the pool already contains a
     * string equal to this {@code String} object as determined by
     * the {@link #equals(Object)} method, then the string from the pool is
     * returned. Otherwise, this {@code String} object is added to the
     * pool and a reference to this {@code String} object is returned.
     * <p>
     * It follows that for any two strings {@code s} and {@code t},
     * {@code s.intern() == t.intern()} is {@code true}
     * if and only if {@code s.equals(t)} is {@code true}.
     * <p>
     * All literal strings and string-valued constant expressions are
     * interned. String literals are defined in section 3.10.5 of the
     * <cite>The Java&trade; Language Specification</cite>.
     *
     * @return  a string that has the same contents as this string, but is
     *          guaranteed to be from a pool of unique strings.
     */
    public native String intern();
~~~

方法区和运行时常量池溢出

​	由于运行时常量池是方法区的一部分，所有这两个区域的溢出测试可以放在一起进行。前面曾经提到HotSpot从JDK7开始逐步“去永久代”的计划，并在JDK8完全使用元空间来代替永久代的背景故事，在此我们就以测试代码来观察一下，使用“永久代”还是“元空间”来实现方法区，对程序有什么实际的影响

​	String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中资格字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。再JDK6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过-XX: PermSize和-XX: MaxPerSize限制永久代的大小，即可间接限制其中常量池的容量

结果：

~~~java
58tongcheng
58tongcheng
true

java
java
false
~~~

除了java 其他的都是true。

原因：sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化，而在初始化时他需要对静态常量字段根据指定的常量值（ConstantValue）做默认初始化，此时被sun.misc.Version.launcher静态常量字段所引用的“java”字符串字面量就被intern到HostSpot VM的字符串常量池——StringTable里了



### 两数求和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

~~~java
/**
     * 通过双重循环遍历数组中所有元素的两两组合
     * 当出现符合的和时返回两个元素的下标
     * @param nums
     * @param target
     * @return
     */
    public static int[] twoSum1(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i+1; j < nums.length; j++) {
                if(target-nums[i]==nums[j]){
                    return new int[]{i,j};
                }
            }
        }
        return null;
    }
//更优解
    /**
     * 哈希
     * @param nums
     * @param target
     * @return
     */
    public static int[] twoSum2(int[] nums, int target) {
        Map<Integer,Integer> map=new HashMap<>();
        for (int i=0;i<nums.length;i++){
            int partnerNumber = target - nums[i];
            if(map.containsKey(partnerNumber)){
                return new int[]{map.get(partnerNumber),i};
            }
            map.put(nums[i],i);
        }
        return null;
    }

~~~

## JUC

### 可重入锁

可重入锁（又名递归锁）是指同一个线程在外层方法获取锁的时候，在进入该线程的内层方法会自动获取锁（前提，锁对象得是同一个对象）,不会因为之前已经获取过还没释放而阻塞。

Java中ReetrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁

可重入锁的种类

隐式锁（及Synchronized关键字使用的锁）默认是可重入锁

同步代码块

~~~java
public class ReEnterLockDemo {

    static Object objectLockA=new Object();

    public static void m1(){
        new Thread(()->{
            synchronized(objectLockA){
                System.out.println(Thread.currentThread().getName()+"\t"+"---外层调用");
                synchronized(objectLockA){
                    System.out.println(Thread.currentThread().getName()+"\t"+"---中层调用");
                    synchronized(objectLockA){
                        System.out.println(Thread.currentThread().getName()+"\t"+"---内层调用");
                    }
                }
            }
        },"t1").start();
    }

    public static void main(String[] args) {
        m1();
    }
}

~~~

同步方法

~~~java
public class ReEnterLockDemo {

    public synchronized static void m1(){
        System.out.println("-------外");
        m2();
    }

    public synchronized static void m2(){
        System.out.println("-------中");
        m3();
    }

    public synchronized static void m3(){
        System.out.println("-------内");
    }

    public static void main(String[] args) {
        m1();
    }
}
~~~

synchronized的重入的实现原理

每一个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针

当执行monitorenter时，弱国目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将计数器加1.

在目标对象的计数器不为零的情况下，如果锁对象的持有线程时当前线程，那么Java虚拟机就可以将其计数器加1，否则需要等待，直至持有线程释放该锁。

当执行monitorexit时，Java虚拟机则需要将锁对象的计数器减1.计数器为零代表锁以被释放。

显式锁（及Lock）ReentrantLock这样的可重入锁

~~~java
public class ReEnterLockDemo {

    static Lock lock=new ReentrantLock();

    public static void main(String[] args) {
        new Thread(()->{
            lock.lock();
            try {
                System.out.println("======外");
                lock.lock();
                try {
                    System.out.println("======内");
                }finally {
                    lock.unlock();
                }
            }finally {
                lock.unlock();
            }
        },"t1").start();
    }
}

~~~





